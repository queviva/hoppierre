<!doctype html><html lang="en">

<head>
	<title>hoppierre</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<link rel="icon" type="image/x-icon" href="favicon.ico">
	<script defer src="nanopicker.js"></script>
    <script src="sketch.js"></script>
	<style id="docStyles">
		* {
			box-sizing: border-box;
			word-wrap: break-word;
			--hue: 48;
			--sat: 100%;
			--lit: 88%;
			--color: hsl(var(--hue), var(--sat), var(--lit));
			--backcolor: hsl(120, 100%, 13%);
			--litback: hsla(120, 50%, 25%);
		}

		body {
			padding: 0px;
			margin: 0px;
			background-color: #000;
			hyphens: auto;
			text-align: center;
		}

		#holder {
			xdisplay: inline-grid;
			xgrid-template-columns: 1fr;
			xgrid-template-rows: 1fr 1fr;
			padding: 0px;
			font-size: 24px;
			text-align: justify;
			xxxmax-width: 700px;
			width: 100%;
			height: 100vh;
			margin: auto;
			xxxborder: 1px solid #000;
			background-color: var(--backcolor);
			color: var(--color);
			xz-index: 2;
		}

		#discussion {
			margin: 0px;
			overflow-x: hidden;
			overflow-y: auto;
			min-height: 40px;
		}

		.addendum {
			font-size: 0.9em;
			opacity: .3;
		}

		div {
			position: relative;
			margin: 0;
			padding: 0;
		}

		hr {
			border-top: 1px solid var(--color);
			border-bottom: none;
			border-left: none;
			border-right: none;
			margin: 50px 0px 50px 0px;
		}

		img {
			xxxwidth: 100%;
			xxxmax-width: 400px;
		}

		a,
		a:visited {
			color: var(--color);
			text-decoration: none;
			transition: 300ms linear color;
		}

		a:hover {
			color: #e86;
			transition: 300ms linear color;
		}

		input {
			--thumbH: 40px;
			--color: 48, 100%;
			--lightness: 88%;
			--midness: var(--lightness);
			/*calc(0.37 * var(--lightness));*/
		}

		input[type=range] {
			-webkit-appearance: none;
			-moz-appearance: none;
			display: inline-block;
			padding: 0;
			margin: 0;
			height: var(--thumbH);
			width: 100%;
			border-radius: calc(var(--thumbH) / 2);
			background-color: hsla(0, 100%, 100%, 0.3);
			pointer-events: none;
		}

		input[type=range]::-webkit-slider-thumb {
			-webkit-appearance: none;
			background-color: hsl(var(--color), var(--lightness));
			opacity: 1.7;
			height: var(--thumbH);
			margin-bottom: 0px;
			width: var(--thumbH);
			border: calc(0.1 * var(--thumbH)) solid;
			border-color: var(--backcolor);
			border-radius: calc(var(--thumbH) / 2);
		}

		input[type=range]:focus {
			outline: none;
		}

		/*possibly a portrait mobi-fone*/
		@media screen and (max-width:500px) {

			input {
				--thumbH: 30px;
			}

			dd {
				font-size: 16px;
				margin-left: 20px;
			}

		}

		/*possibly a mobile landscaper*/
		@media screen and (orientation: landscape) and (max-width: 760px) {

            /*
			#holder {
				height: 500px;
				width: 100%;
				max-width: none;
			}
			*/

		}
		
		.signature {
		    width: 100%;
		    text-align: right;
		}
		
	</style>
	<style id="svgStyles">
	
		svg {
		    padding: 0;
		    margin: 0;
		    width: 100%;
		    height: 100%;
		    xborder: 4px solid #c30;
		    top: 0;
		    left: 0;
		    position: absolute;
		    xxxbackground-color: #888;
		    xxxbackground: url(bag0.jpg);
		    xxxbackground-size: cover;

		}
		
		path, g {
		    xxxtransition: all linear 200ms;
		}
		
		#svgHolder {
		    --nose-h: 32;
		    --nose-s: 100%;
		    --nose-l: 70%;
		    --nose-a: 1;
		    --nose-hsla: '32 100 70 1';
		    --lightness: hsl(
		        var(--nose-h),
		        var(--nose-s),
		        var(--nose-l)
		    );
		    --midness: hsl(
		        var(--nose-h),
		        var(--nose-s),
		        calc(0.7 * var(--nose-l))
		    );
		    --darkness: hsl(
		        var(--nose-h),
		        var(--nose-s),
		        calc(0.35 * var(--nose-l))
		    );
		    --blackness: hsl(
		        var(--nose-h),
		        var(--nose-s),
		        calc(0.20 * var(--nose-l))
		    );
			position: relative;
			padding: 0;
			margin: 0;
			width: 100%;
			height: 100vh;
			xxmax-height: 300px;
			padding-top: calc(40% - 7px);
			overflow: hidden;
			user-select: none;
		}

		#logoDiv {
			position: absolute;
			right: 0px;
			bottom: 0px;
			padding: 2px;
			opacity: 0.3;
			font-style: italic;
			font-size: 20px;
			color: var(--axis-color);
			user-select: none;
		}

		input[type=checkbox] {

			width: 30px;
			height: 30px;
			vertical-align: middle;
			accent-color: var(--axis-color);

		}

		label {
			font-style: italic;
		}

		/*possibly a portrait mobi-fone*/
		@media screen and (max-width:500px) {

			#svgHolder {
				border-width: 2px;
			}

		}
	</style>
	<style id="mathStyles">
		/* (c) Aardvark Aaronson */

		frac {
			display: inline-grid;
			grid-template-columns: 1fr;
			grid-template-rows: 1fr 1fr;
			font-style: italic;
			font-size: 0.6em;
			vertical-align: middle;
			text-align: center;
		}

		num {
			border-bottom: 1px solid;
		}

		num::before {
			content: "\00a0\00a0";
		}

		num::after {
			content: "\00a0\00a0";
		}

		sup {
			font-size: 0.6em;
		}

		sub {
			font-size: 0.6em;
		}

		com {
			font-size: 0.5em;
		}

		com::before {
			content: "\00a0\00a0\00a0[";
		}

		com::after {
			content: "]";
		}

		whr {
			border-left: 1px solid;
			padding: 0.5em;
			margin-left: 1.25em;
			font-size: 0.7em;
			vertical-align: middle;
		}

		dd {
			margin-top: 15px;
		}
	</style>
</head>

<body>
<div id="holder">

    <div id="svgHolder">

        <svg
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-100 -50 200 100"
         transform="scale(1.0)"
         preserveAspectRatio="xMidYMid"
        >
            
            <defs>
                <linearGradient id="shade" y2="70%">
                    <stop offset="30%" stop-color="
                        hsl(
                            var(--nose-h),
                            var(--nose-s),
                            calc(0.1 * var(--nose-l))
                        )
                    " stop-opacity="0.7" />
                    <stop offset="100%" stop-color="
                        hsl(
                            var(--nose-h),
                            var(--nose-s),
                            calc(0.1 * var(--nose-l))
                        )
                    " stop-opacity="0.5" />
                </linearGradient>
            </defs>

            <style>
            
                @keyframes echoAni {
                    0% {
                        transform: scale(0.1);
                        opacity: 0;
                    }
                    10% {
                        opacity: 1;
                    }
                    100% {
                        transform: scale(var(--xtra));
                        opacity: 0;
                    }
                }
                
                @keyframes shineAni {
                    
                    0% {
                        d: path(var(--small-d));
                        opacity: 0;
                        transform: rotate(49deg);
                    } 100% {
                        d: path(var(--large-d));
                        opacity: 0.5;
                        transform: rotate(-14deg);
                    }
                    
                }
                
                @keyframes shockAni {
                    0% {
                        transform: translate(0px, 0px) scale(0.0);
                        opacity: 0;
                    }
                    10% {
                        opacity: 1;
                    }
                    100% {
                        transform: translate(-5px, -3px) scale(0.8);
                        opacity: 0;
                    }
                }
                
                #echoGroup > g > g {
                    opacity: 0;
                    animation-name: echoAni;
                    animation-timing-function: linear;
                }
                
                #echoGroup > g > g > path {
                    
                    d: path('\
                        M  0 0 a 100 30 0 1 0 0 0.001 Z \
                        M -7 1 a  95 27 0 1 0 0 0.001 Z \
                    ');
                    
                    fill: hsla(var(--nose-h), 100%, 100%, 0.1);
                    stroke: none;
                    vector-effect: non-scaling-stroke;
                    fill-rule: evenodd;
                    
                    transform: translateX(100px) rotate(-5deg);
                    
                }
                
                #boxShadow {
                    fill: hsla(0, 0%, 0%, 0.8);
                }
                
                #boxBody {
                    fill: var(--midness);
                }
                
                #boxBodyLine {
                    fill: none;
                    stroke: var(--darkness);
                    stroke-width: 0.8px;
                }
                
                #boxBodyLineXtra {
                    fill: none;
                    stroke: hsla(var(--nose-h),100%,100%,0.7);
                    stroke-width: 0.1px;
                }
                
                #boxShade {
                    xxxfill: url(#shade);
                    xxxstroke: hsla(var(--nose-h) 0%, 0%, 0.5);
                    fill: hsla(
                        var(--nose-h),
                        100%,
                        calc(0.4 * var(--nose-l)),
                        0.4
                    );
                    stroke: none;
                }
                
                #boxShadeLine {
                    fill: none;
                    stroke: var(--darkness);
                    stroke-width: 0.1px;
                }
                
                #shineGroup > g > path {
                    
                    --small-d: '\
                        M 0 -0 L 0.5 -0.87    \
                        L 0  0 L 1 0          \
                        L 0  0 L 0.5 0.87     \
                        L 0  0 L -0.5 0.87    \
                        L 0  0 L -1 0         \
                        L 0  0 L -0.5 -0.87   \
                        Z \
                    ';
                    
                    --large-d: '\
                        M  0   -20  L  0.5 -0.87    \
                        L  6.9  -4  L  1 0          \
                        L  4.3 2.5  L  0.5 0.87     \
                        L  0    16  L -0.5 0.87     \
                        L -9.5 6.5  L -1 0          \
                        L -8.7  -5  L -0.5 -0.87    \
                        Z \
                    ';
                    
                    fill: hsla(var(--nose-h), 100%, 100%, 1);
                    vector-effect: non-scaling-stroke;
                    fill-rule: evenodd;
                    animation-name: shineAni;
                    animation-timing-function: ease-out;
                    opacity: 0;
                    
                }
                
                #shockGroup > g > g {
                    --xtra: 0.8;
                    animation-name: shockAni;
                    animation-timing-function: linear;
                    opacity: 0;
                }
                
                #shockGroup > g > g > path {
                    
                    d: path('\
                        M 0 0 a 2 5 0 1 0 0 0.001 Z \
                        M -0.2 0.5 a 1.8 3.5 -5 1 0 0 0.001 Z \
                    ');
                   
                    transform: translate(0px, -4px) scale(3);
                    fill: hsla(var(--nose-h), 100%, 100%, 0.4);
                    stroke: none;
                    fill-rule: evenodd;
                }
                
            </style>
            
            <g id="echoGroup" style="
                transform: translate(15px, 15.5px);
            "/>
            <g id="boxOver" style="transform:translate(0, -15px)">
            <g id="boxMirror" data-nose="#svgHolder" style="
                transform-origin: 15px 0px;
                transform: scale(1, 1);
                transition: none;
            ">
                <path id="boxShadow"/>
                <g id="boxGroup">
                    <path id="boxBody"/>
                    <path id="boxShade"/>
                    <path id="boxShadeLine"/>
                    <path id="boxBodyLine"/>
                    <path id="boxBodyLineXtra"/>
                    <g id="shineGroup"/>
                </g>
            </g></g>
            
            <g id="shockGroup"/>
            
            <!--g id="circOver" transform="
                translate(-50, -4) scale(0.3)
            ">
                <ellipse id="circShadow" rx="20" ry="5"
                    fill="hsla(300,100%,0%,0.45)"
                    cx="20" cy="30"
                />
                <g id="circGroup" transform="rotate(-5)">
                    <ellipse id="circLine" rx="9" ry="21"
                     style="fill:hsla(0,100%,15%,1)"/>
                    <ellipse id="circBody" rx="8" ry="18"
                     style="fill:hsla(300,100%,50%,1)"/>
                    <path id="circShade"i
                     style="
                        fill:hsla(0,100%,30%,0.3)
                     "
                     d="M-6 11 C 2 31 13 3 5 -12 C 3 -16 6 15 -6 11Z"
                    />
                </g>
            </g-->
        
        </svg>
        
        <style>
        
        #RTC, #LTC {
            position: absolute;
            box-sizing: border-box;
            padding: 0;
            margin: 0;
            bottom: 0px;
        }
        
        #RTC {
            right: 0px;
        }
        
        #RTC > div, #LTC > div {
            box-sizing: border-box;
            position: relative;
            width: 165px;
            height: 90px;
        }
        
        #RTC > div > div, #LTC > div > div {
            box-sizing: border-box;
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid hsla(0, 0%, 0%, 0.2);
            background-color: hsla(0, 100%, 100%, 0.05);
            text-align: center;
            line-height: 45px;
            user-select: none;
        }
        
        #RTC > div > div:nth-of-type(1) {
            left: 0px;
            bottom: 10px;
        }
        
        #RTC > div > div:nth-of-type(2) {
            left: 14px;
            bottom: 60px;
        }
        
        #RTC > div > div:nth-of-type(3) {
            left: 55px;
            bottom: 30px
        }
        
        #RTC > div > div:nth-of-type(4) {
            left: 37px;
            bottom: 28px;
            width: 32px;
            height: 32px;
            border: none;
            background-color: hsla(0,0%,0%,0);
        }
        
        #RTC > div > div:nth-of-type(5) {
            
            left: 92px;
            bottom: 50px;
            width: 32px;
            height: 32px;
            border: none;
            background-color: hsla(0,0%,0%,0);
            
        }
        
        #LTC > div > div:nth-of-type(1) {
            height: 80px;
            width: 80px;
            bottom: 8px;
            left: 18px;
        }
        
        </style>

        <div id="RTC"><div>
            <div id="Skey"></div>
            <div id="Ekey"></div>
            <div id="Fkey"></div>
            <div id="SEkey"></div>
            <div id="EFkey"></div>
        </div></div>

        <div id="LTC"><div>
            <div id="ShiftButt"></div>
        </div></div>

    </div>

</div>
</body>

<script id="hopScript">

////////////////////////////////////////////////////////////{
// licensed from Aardvark Aaronson, November 2022          //
// MCMLXXXVIII                                             //
//                                                         //
////////////////////////////////////////////////////////////}

// expiration date {
Date.now() < new Date('2023-10-13') &&

((dset = document.currentScript.dataset) =>
document.addEventListener('DOMContentLoaded', () => {
    
    // prefs {
    
    const prefs = {
        moveStall : 100,
        keyComboLimit : 180,
        touchComboLimit : 180,
    }

    //}
                
    // utils {
        
    const log = console.log;
    const rand = Math.random;
    const round = Math.round;
        
    //}
    
    // vars and refs {
    
    let canKey = true;
    let canTouch = true;
    let mirror = 1;
    
    const NS = 'http://www.w3.org/2000/svg';
    
    const holder = document.getElementById('holder');
    const boxGroup = document.getElementById('boxGroup');
    const boxOver = document.getElementById('boxOver');
    boxOver.style.setProperty('--xtra', 1 + rand()*3);
    const boxShadow = document.getElementById('boxShadow');
    const boxBody = document.getElementById('boxBody');
    const boxShade = document.getElementById('boxShade');
    const boxLite = document.getElementById('boxLite');
    const shineGroup = document.getElementById('shineGroup');
    const logoDiv = document.getElementById('logoDiv');
    const RTC = document.getElementById('RTC');
    const Skey = document.getElementById('Skey');
    const Fkey = document.getElementById('Fkey');
    const Ekey = document.getElementById('Ekey');
    const SEkey = document.getElementById('SEkey');
    const EFkey = document.getElementById('EFkey');
    const ShiftButt = document.getElementById('ShiftButt');
    
    const rough = sketch.svg(boxOver);
    
    //}
    
    // poses {
    
    const POS = {
        
        shadow: {
            
            stand: `path('M 10 22 L 40 22 L 25 14 L 14 14.5L 4 16 Z')`,
            
            quarterTurn: `path('M 6.5 21 Q 22 22 38 22 L 30 15 L 20 15 L 4 14 Z')`,
            
            frontLift: `path('M 10 22 L 39 22 L 24 14 L 14 14.5 L 4 16 Z')`,
            
            backLift: `path('M 12 22 L 40 22 L 25 12 L 12 14 L 6.0 16 Z')`,
            
            squat: `path('M 10 22 L 38.5 22 L 23 14 L 14 14.5 L 4 16 Z')`,
            
            squatSemi: `path('M 10 22 L 39 22 L 24 14 L 14 14.5 L 4 16 Z')`,
            
            squatXtra: `path('M 10 22 L 38 22 L 22 14 L 14 14.5 L 4 16 Z')`,
            
            back: `path('M 10 22 L 39 22 L 24 14 L 14 14.5 L 4 16 Z')`,
            
            backSemi: `path('M 10 22 L 38 22 L 23 14 L 14 14.5 L 4 16 Z')`,
                  
            arch: `path('M 10 22 L 40 22 L 25 14 L 14 14.5L 4 16 Z')`,
            
            archFlat: `path('M 10 22 L 40 22 L 25 14 L 14 14.5L 4 16 Z')`,
            
            archXtra: `path('M 10 22 L 41 22 L 25.5 14 L 14 14.5 L 4 16 Z')`
            
            
        },
        
        body: {
            
            stand: `path('M -1 0 L 1.5 8 L 4 16 L 10 22 Q 26 19 26 19 Q 30 -3 30 -3 L 13 -8 Q -1 0 -1 0 Z')`,
        
            quarterTurn: `path('M 0 -3 L 3.4 10 L 4 14 L 6.5 21 Q 16 19 24 20 Q 24 8 29 -2.4  L 18.5 -10 Q 8 -9.4 0 -3 Z')`,
            
            frontLift: `path('M -1 0 L 2 10 L 1 14 L 8 20 L 23.5 20 L 28 12 L 30 -3 L 13 -8 Q 6 -3 -1 0 Z')`,
            
            backLift: `path('M -1 0 L 2.5 12 L 4.5 15.5 L 11 21 L 28 16 L  27 12 L 30 -3 L 13 -8 Q  5 -4.5 -1 0 Z')`,
            
            squat: `path('M -1 1 L 2 12 L 4 16 L 10 22 Q 26 19 26 19 Q 30 10 30 -2 L 13 -7 Q 6 -2 -1 1 Z')`,
            
            squatSemi: `path('M -1 0.5 L 2.3 12 L 4 16 L 10 22 Q 26 19 26 19 Q 29 10 30 -2.5 L 13 -7 Q 7 -3 -1 0.5 Z')`,
            
            squatXtra: `path('M -1 2 L 1.4 12  L 4 16 L 10 22 Q 26 19 26 19 Q 32 10 30 -1 L 13.2 -5 Q 6 0 -1 2 Z')`,
        
            back: `path('M -1 2 L 4 12 L 4 16 L 10 22 Q 26 19 26 19 Q 33 10 30 -1 L 13 -6 Q 7 -0.5 -1 2 Z')`,
            
            backSemi: `path('M -1 1 L 3.2 12 L 4 16 L 10 22 Q 26 19 26 19 Q 30 10 30 -2 L 13 -7 Q 6 -1.5 -1 1 Z')`,
        
            arch: `path('M -1 0 L 1.5 8 L 4 16 L 10 22 Q 18 19 26 19 Q 30 -3 30 -3 L 13 -8 Q 6 -6 -1 0 Z')`,
            
            archFlat: `path('M -1 -0.5 L 3.2 12 L 4 16 L 10 22 Q 26 19 26 19 Q 27 7 30 -3.5 L 13 -8.5 Q 6 -6.2 -1 -0.5 Z')`,
            
            archXtra: `path('M -1 -1 L 3.2 12 L 4 16 L 10 22 Q 18 19.5 26 19 Q 26 8 30 -4 L 13 -9 Q 6 -7 -1 -1 Z')`,
            
            slice: `path('M 3 0 L 4 10 L -9 12 L 14 23 L 26 19 L 25.5 17 Q 30 10 35 -2 L 24 -4 L 16.5 -7 Z')`,
            
            sliceSemi: `path('M 1 0 L 3.3 10 L -3 13.5 L 12 22.3 L 26 19 L 26 17 L 34 -2.4 Q 30.3 -4 23 -4 L 15.3 -7 Z')`
            
        },
        
        shade: {
            
            stand: `path('M 9 8 L 9.5 15 L 10 22 Q 26 19 26 19 Q 30 -3 30 -3 Q 9 8 9 8 Z')`,
        
            quarterTurn: `path('M 5 7 L 6 15 L 6.5 21 Q 16 19 24 20 Q 24 8 29 -2.4 Q 18 -1.5 5 7 Z')`,
       
            frontLift: `path('M 9 8 L 9.5 15 L 8 20 L 23.5 20 L 28 12 L 30 -3 Q 20 3 9 8 Z')`,
            
            backLift: `path('M 9 8 L 9.25 17 L 11 21 L 28 16 L 27 12 L 30 -3 Q 19 0.25 9 8 Z')`,
            
            squat: `path('M 9 9 L 9.3 17 L 10 22 Q 26 19 26 19 Q 30 10 30 -2 Q 20 5 9 9 Z')`,
            
            squatSemi: `path('M 9 8.5 L 9.4 17 L 10 22 Q 26 19 26 19 Q 29 10 30 -2.5 Q 20 4 9 8.5 Z')`,

            squatXtra: `path('M 9 10 L 9 18 L 10 22 Q 26 19 26 19 Q 32 10 30 -1 Q 20 7 9 10 Z')`,
            
            back: `path('M 9 10 L 10.75 17 L 10 22 Q 26 19 26 19 Q 33 10 30 -1 Q 18.5 7.5 9 10 Z')`,
            
            backSemi: `path('M 9 9 L 10.25 17 L 10 22 Q 26 19 26 19 Q 30 10 30 -2 Q 20 5 9 9 Z')`,
            
            arch: `path('M 9 8 L 9.5 15 L 10 22 Q 18 19 26 19 Q 30 -3 30 -3 Q 20 0 9 8 Z')`,
            
            archFlat: `path('M 9 7.5 L 9.75 15 L 10 22 Q 26 19 26 19 Q 27 7 30 -3.5 Q 20 0 9 7.5 Z')`,
            
            archXtra: `path('M 9 7 L 9.5 15 L 10 22 Q 18 19.5 26 19 Q 26 8 30 -4 Q 20 -1 9 7 Z')`,
            
            slice: `path('M 19 9 L 13.8 23.3 L 14 23 L 26 19 L 25.5 17 L 35 -2 Z')`,
            
            sliceSemi: `path('M 15 9 L 11.8 20 L 12 22.3 L 26 19 L 26 17 L 34 -2.4 Z')`,
            
        }
        
    }
    
    //}
    
    // objects {
        
    function Sprite (vals) {
    
        vals = Object.assign({
            obj: '',
            cssVars : [],
            steps: {}
        }, vals);
    
        this.obj = vals.obj;
        
        this.cssVars = vals.cssVars;
        this.setLoopVars();
        
        this.steps = vals.steps;
    
    }
    
    Sprite.prototype.makeAniRule = function () {
        
        let rule = '@keyframes ' + this.obj.id + 'Ani {\n';
    
        let arr = Array.from(Object.entries(this.steps));
        let len = arr[0][1].length;
    
        for (let i = 0, j = len; i < j; i++) {
            
            let perc = round(100 * (i / (j)));
            
            rule += '\t'+ perc + '% {\n'
    
            arr.forEach(s => rule += '\t\t'+ s[0] +':'+ s[1][i] +';\n');
    
            rule += '\t}\n';
            
            perc = round(100 * ((i+1)/(j))) - 1;
                
            rule += '\t' + (perc === 99 ? 100 : (perc +'.9')) +'%{\n';
            
            arr.forEach(s => rule += '\t\t' +s[0] +':'+ s[1][i] +';\n');
            
            rule += '\t}\n';
            
        }
    
        rule += '}'
        
        svgStyles.sheet.insertRule(rule);
        
        this.obj.style.animationName = this.obj.id+'Ani';
        this.obj.style.animationDuration =  1000 +'ms';
        this.obj.style.animationDelay = 'none';
        this.obj.style.animationDirection = 'end';
        this.obj.style.animationFillMode = 'forward';
        this.obj.style.animationIterationCount = 'infinite';
        this.obj.style.animationPlayState = 'running';
        
    };
    
    Sprite.prototype.setLoopVars = function () {
        
        this.cssVars.forEach(v => {
            v[0].style.setProperty(v[1], v[2]());
        });
        
    };
    
    Sprite.prototype.show = function (n) {
        
        for (let [v, k] of Object.entries(this.steps)) {
            
            if (n % k.length === 0 && this.cssVars.length > 0) {
                this.setLoopVars();
            }
            
            if (v === 'd' && this.obj === boxBody) {
            
                boxBodyLine.style.setProperty('d', 'path("' +
                    rough.path(
                        k[n % k.length]
                        .replace(/path\(/, '')
                        .replace(/[\)\`\']/g, ''), {
                            fill: '#ccc',
                            stroke: '#000',
                            roughness: 0.3
                        }
                    ).children[1].getAttribute('d') + '")'
                );
            
                boxBodyLineXtra.style.setProperty('d', 'path("' +
                    rough.path(
                        k[n % k.length]
                        .replace(/path\(/, '')
                        .replace(/[\)\`\']/g, ''), {
                            fill: '#ccc',
                            stroke: '#000',
                            roughness: 1.3
                        }
                    ).children[1].getAttribute('d') + '")'
                );
            
                this.obj.style.setProperty(v, k[n % k.length]);
            
            }
            
            else if (v === 'd' && this.obj === boxShade) {
            
                //boxShade.style.setProperty('fill', 'none');
                //boxShade.style.setProperty('stroke', 'url(#shade)');
                boxShadeLine.style.setProperty('d', 'path("' +
                    rough.path(
                        k[n % k.length]
                        .replace(/path\(/, '')
                        .replace(/[\)\`\']/g, ''), {
                            fill: '#fff',
                            fillStyle: 'cross-hatch',
                            fillWeight: 2,
                            bowing: 8,
                            hachureGap: 0.8,
                            hachureAngle: 55,
                            stroke: '#c30',
                            roughness: 0.3
                        }
                    ).children[0].getAttribute('d') +
                    '")');
            
                this.obj.style.setProperty(v, k[n % k.length]);
            
            }
            
            else if (v === 'd' && this.obj === boxShadow) {
            
                boxShadow.style.setProperty('fill', 'none');
                boxShadow.style.setProperty('stroke', 'hsla(0,0%,0%,0.5');
                boxShadow.style.setProperty('stroke-width', '0.5px');
                boxShadow.style.setProperty('d', 'path("' +
                    rough.path(
                        k[n % k.length]
                        .replace(/path\(/, '')
                        .replace(/[\)\`\']/g, ''), {
                            fill: '#fff',
                            fillStyle: 'hachure',
                            fillWeight: 2,
                            bowing: 8,
                            hachureGap: 0.8,
                            hachureAngle: -55,
                            stroke: '#c30',
                            roughness: 0.3
                        }
                    ).children[0].getAttribute('d') +
                    '")');
            
                //this.obj.style.setProperty(v, k[n % k.length]);
            
            }
            
            else {
            
                this.obj.style.setProperty(v, k[n % k.length]);
                
            }
            
        }
        
    }
    
    Sprite.prototype.dispatchEnd = function () {
        
        this.obj.dispatchEvent(new CustomEvent('spriteend', {
            detail: this.obj.id
        }));
        
    };
    
    function Echo (x=0, y=0, delay=100, duration=1500, xtra=1.4) {
    
        const g = document.createElementNS(NS, 'g');
        g.style.setProperty('animation-delay', delay +'ms');
        g.style.setProperty('animation-duration', duration +'ms');
        g.style.setProperty('--xtra', xtra);
        g.append(document.createElementNS(NS, 'path'));
        
        const G = document.createElementNS(NS, 'g');
        G.style.transform ='translate('+ x +'px, '+ y +'px)';
        G.append(g);
        
        echoGroup.append(G);
        
        g.addEventListener('animationend', e => {
            echoGroup.removeChild(G);
        });
        
    }
        
    function Shine (duration=500, delay=0) {
    
        const G = document.createElementNS(NS, 'g');
        
        const P = document.createElementNS(NS, 'path')
        P.style.setProperty('animation-duration', duration +'ms');
        P.style.setProperty('animation-delay', delay +'ms');
        P.addEventListener('animationend', e => {
            shineGroup.removeChild(G);
        });
        
        G.append(P);
        shineGroup.append(G);
        
    }
     
    function Shock (x=0, y=0, delay=210, duration=200, xtra=1.4) {
    
        const g = document.createElementNS(NS, 'g');
        g.style.setProperty('animation-delay', delay +'ms');
        g.style.setProperty('animation-duration', duration +'ms');
        g.style.setProperty('--xtra', xtra);
        g.append(document.createElementNS(NS, 'path'));
        
        const G = document.createElementNS(NS, 'g');
        G.style.transform ='translate('+ x +'px, '+ y +'px)';
        G.append(g);
        
        shockGroup.append(G);
        
        g.addEventListener('animationend', e => {
            shockGroup.removeChild(G);
        });
        
    }
       
    function SSet (name, size, stall, spriteset) {
        
        this.name = name;
        this.size = size;
        this.stall = stall;
        this.set = spriteset;
    
    }
    
    SSet.prototype.show = function (n) {
        this.set.forEach(s => log(s));
    }
    
    //}
        
    // all sprites {
    
    const allSprites = {
    
    // standing-still-bob
    bobbing : [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.archXtra,
                    POS.shadow.stand
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
        POS.body.squatSemi,
        POS.body.stand,
        POS.body.archFlat,
        POS.body.stand,
        POS.body.squat,
        POS.body.stand,
        POS.body.archXtra,
        POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
        POS.shade.squatSemi,
        POS.shade.stand,
        POS.shade.archFlat,
        POS.shade.stand,
        POS.shade.squat,
        POS.shade.stand,
        POS.shade.archXtra,
        POS.shade.stand
        
                ]
            }
        },
        
        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px)'
                ]
            }
        }
        
    ].map(s => new Sprite(s)),
    
    // duck and hide
    duckoff : [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    
                    POS.shadow.squatSemi,
                    POS.shadow.squat,
                    POS.shadow.squatXtra,
                    POS.shadow.squatXtra,
                    POS.shadow.squatXtra,
                    POS.shadow.squat
                    
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
        POS.body.squatSemi,
        POS.body.squat,
        POS.body.squatXtra,
        POS.body.squatXtra,
        POS.body.squatXtra,
        POS.body.squat
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
        POS.shade.squatSemi,
        POS.shade.squat,
        POS.shade.squatXtra,
        POS.shade.squatXtra,
        POS.shade.squatXtra,
        POS.shade.squat
        
                ]
            }
        },

    ].map(s => new Sprite(s)),
  
    // up-and-down hop
    hopping : [
        
        // boxShadow
        {
            obj: boxShadow,
            cssVars: [[boxOver, '--xtra', () => 1 + 3 * rand()]],
            steps: {
                d: [
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand
                ],
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(calc(1.0px * var(--xtra)))',
                    'translate(calc(2.0px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(2.7px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(2.2px * var(--xtra)))',
                    'translate(calc(1.0px * var(--xtra)))',
                    'translate(0px)'
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
                    
        POS.body.squatSemi,
        POS.body.archFlat,
        POS.body.archXtra,
        POS.body.archXtra,
        POS.body.archXtra,
        POS.body.archXtra,
        POS.body.archXtra,
        POS.body.archXtra,
        POS.body.archXtra,
        POS.body.stand
        
                ]
            }
        },

        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
                    
        POS.shade.squatSemi,
        POS.shade.archFlat,
        POS.shade.archXtra,
        POS.shade.archXtra,
        POS.shade.archXtra,
        POS.shade.archXtra,
        POS.shade.archXtra,
        POS.shade.archXtra,
        POS.shade.archXtra,
        POS.shade.stand
        
                ]
            }
        },
        
        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px, 0px)',
                    'translate(0px, 0px)',
                    'translate(0px, calc(-1.2px * var(--xtra)))',
                    'translate(0px, calc(-2.4px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-3.3px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-2.4px * var(--xtra)))',
                    'translate(0px, calc(-1.2px * var(--xtra)))',
                    'translate(0px, 0px)'
                ]
            }
        },
        
        // shineGroup
        {
            obj: shineGroup,
            steps: {
                transform: [
                    'translate(-1px, 0.5px)',
                    'translate(-1px, -0.5px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, -1px)',
                    'translate(-1px, 0px)'
                ]
            }
        }
        
    ].map(s => new Sprite(s)),
   
    // hop and kick
    hopkick: [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.backSemi,
                    POS.shadow.back,
                    POS.shadow.arch,
                    POS.shadow.archXtra,
                    POS.shadow.archXtra,
                    POS.shadow.frontLift,
                    POS.shadow.frontLift,
                    POS.shadow.archFlat,
                    POS.shadow.stand
                ],
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(calc(2.0px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(1.0px * var(--xtra)))',
                    'translate(0px)'
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
                    POS.body.backSemi,
                    POS.body.back,
                    POS.body.arch,
                    POS.body.archXtra,
                    POS.body.archXtra,
                    POS.body.frontLift,
                    POS.body.frontLift,
                    POS.body.archFlat,
                    POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
                    
                    POS.shade.backSemi,
                    POS.shade.back,
                    POS.shade.arch,
                    POS.shade.archXtra,
                    POS.shade.archXtra,
                    POS.shade.frontLift,
                    POS.shade.frontLift,
                    POS.shade.archFlat,
                    POS.shade.stand
        
                ]
            }
        },

        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px, calc(-2.2px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-2.2px * var(--xtra)))',
                    'translate(0px)'
                ]
            }
        }
        
    ].map(s => new Sprite(s)),
     
    // hop and pound
    hopaway: [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.back,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.backSemi,
                    POS.shadow.back,
                    POS.shadow.back,
                    POS.shadow.stand
                ],
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(calc(2.0px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(3.2px * var(--xtra)))',
                    'translate(calc(2.7px * var(--xtra)))',
                    'translate(calc(1.8px * var(--xtra)))',
                    'translate(0px)'
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
        POS.body.back,
        POS.body.arch,
        POS.body.archXtra,
        POS.body.stand,
        POS.body.backSemi,
        POS.body.back,
        POS.body.back,
        POS.body.stand
        
                ]
            }
        },
    
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[

        POS.shade.back,
        POS.shade.arch,
        POS.shade.archXtra,
        POS.shade.stand,
        POS.shade.backSemi,
        POS.shade.back,
        POS.shade.back,
        POS.shade.stand
        
                ]
            }
        },
        
        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px, 0px)',
                    'translate(0px, 0px)',
                    'translate(0px, calc(-2.2px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-3.4px * var(--xtra)))',
                    'translate(0px, calc(-3.0px * var(--xtra)))',
                    'translate(0px, calc(-2.2px * var(--xtra)))',
                    'translate(0px, 0px)'
                ]
            }
        }
        
    ].map(s => new Sprite(s)),
    
    // forward kick
    kicking : [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.back,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand
                ],
                transform: [
                    'translate(0px)',
                    'translate(-2px)',
                    'translate(-1px)',
                    'translate(0px)'
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
                    POS.body.back,
                    POS.body.frontLift,
                    POS.body.frontLift,
                    POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
                    POS.shade.back,
                    POS.shade.frontLift,
                    POS.shade.frontLift,
                    POS.shade.stand
        
                ]
            }
        },
        
        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px)',
                    'translate(-3px, -3px)',
                    'translate(-1px, -2px)',
                    'translate(0px)'
                ]
            }
        }
        
    ].map(s => new Sprite(s)),
   
    // forward slice
    slicing : [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)'
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
                    POS.body.sliceSemi,
                    POS.body.slice,
                    POS.body.slice,
                    POS.body.slice,
                    POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d: [
                    
                    POS.shade.sliceSemi,
                    POS.shade.slice,
                    POS.shade.slice,
                    POS.shade.slice,
                    POS.shade.stand
                    
                ]
        
            }
            
        }
        
    ].map(s => new Sprite(s)),
   
    // running forward
    running : [
        
        // boxShadow
        {
            obj: boxShadow,
            cssVars: [[boxGroup, '--xtra', () => 1 + 4 * rand()]],
            steps: {
                d: [
                    POS.shadow.backLift,
                    POS.shadow.backLift,
                    POS.shadow.stand,
                    POS.shadow.frontLift,
                    POS.shadow.stand
                ],
                transform: [
                    'translate(calc(2.0px * var(--xtra)))',
                    'translate(calc(2.5px * var(--xtra)))',
                    'translate(calc(2.2px * var(--xtra)))',
                    'translate(calc(2.0px * var(--xtra)))',
                    'translate(0)'
                ]
            }
        },
       
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
                    POS.body.backLift,
                    POS.body.backLift,
                    POS.body.stand,
                    POS.body.frontLift,
                    POS.body.stand
      
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
                    POS.shade.backLift,
                    POS.shade.backLift,
                    POS.shade.stand,
                    POS.shade.frontLift,
                    POS.shade.stand
      
                ]
            }
        },
        
        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px, calc(-1.5px * var(--xtra)))',
                    'translate(0px, calc(-1.8px * var(--xtra)))',
                    'translate(0px, calc(-2.2px * var(--xtra)))',
                    'translate(0px, calc(-2.0px * var(--xtra)))',
                    'translate(0px)'
                ]
            }
        }
        
    ].map(s => new Sprite(s)),

    // forward punch
    puncher : [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.archXtra,
                    POS.shadow.quarterTurn,
                    POS.shadow.archXtra,
                    POS.shadow.stand
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
        POS.body.archXtra,
        POS.body.quarterTurn,
        POS.body.archXtra,
        POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
                    POS.shade.archXtra,
                    POS.shade.quarterTurn,
                    POS.shade.archXtra,
                    POS.shade.stand
        
                ]
            }
        }
        
    ].map(s => new Sprite(s)),
      
    // punch kick combo
    twister : [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.archXtra,
                    POS.shadow.quarterTurn,
                    POS.shadow.archXtra,
                    POS.shadow.stand,
                    POS.shadow.back,
                    POS.shadow.frontLift,
                    POS.shadow.frontLift,
                    POS.shadow.stand
                ],
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(-2px)',
                    'translate(-1px)',
                    'translate(0px)'
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
                    POS.body.archXtra,
                    POS.body.quarterTurn,
                    POS.body.archXtra,
                    POS.body.stand,
                    POS.body.back,
                    POS.body.frontLift,
                    POS.body.frontLift,
                    POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
                    POS.shade.archXtra,
                    POS.shade.quarterTurn,
                    POS.shade.archXtra,
                    POS.shade.stand,
                    POS.shade.back,
                    POS.shade.frontLift,
                    POS.shade.frontLift,
                    POS.shade.stand
        
                ]
            }
        },
        
        // boxGroup
        {
            obj: boxGroup,
            steps: {
                transform: [
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(0px)',
                    'translate(-3px, -3px)',
                    'translate(-1px, -2px)',
                    'translate(0px)'
                ]
            }
        }
        
        
    ].map(s => new Sprite(s))
    
    };
    
    
    const allNewSprites = [
        
        ['bobbing', 8, 120, [
        
        // boxShadow
        {
            obj: boxShadow,
            steps: {
                d: [
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.stand,
                    POS.shadow.archXtra,
                    POS.shadow.stand
                ]
            }
        },
        
        // boxBody
        {
            obj: boxBody,
            steps: {
                d: [
        
        POS.body.squatSemi,
        POS.body.stand,
        POS.body.archFlat,
        POS.body.stand,
        POS.body.squat,
        POS.body.stand,
        POS.body.archXtra,
        POS.body.stand
        
                ]
            }
        },
        
        // boxShade
        {
            obj: boxShade,
            steps: {
                d:[
        
        POS.shade.squatSemi,
        POS.shade.stand,
        POS.shade.archFlat,
        POS.shade.stand,
        POS.shade.squat,
        POS.shade.stand,
        POS.shade.archXtra,
        POS.shade.stand
        
                ]
            }
        }

        ].map(s => new Sprite(s))]
    ].map(SS => [SS[0], new SSet(...SS)]);
    
    //}
    
    // sprite stalls {
    
    allSprites.bobbing.stall = 120;
    allSprites.duckoff.stall = 100;
    allSprites.hopping.stall = 080;
    allSprites.hopkick.stall = 100;
    allSprites.hopaway.stall = 100;
    allSprites.kicking.stall = 120;
    allSprites.slicing.stall = 120;
    allSprites.running.stall = 240;
    allSprites.puncher.stall = 100;
    allSprites.twister.stall = 080;
    
    //}
    
    // ani method {
            
    const aniMaker = new function () {
    
        this.isLooping = false;
        this.frameCount = 0;
        this.frameEnd = 0;
        this.nextSet = allSprites.bobbing;
        this.spriteSet = allSprites.bobbing;
    
        this.anim = () => {
            
            this.spriteSet.forEach(s => {
                s.show(this.frameCount);
            });
            
            this.frameCount++;
            
            if (this.isLooping) {
                
                if (this.frameCount < this.frameEnd) {
                    
                    this.isLooping = setTimeout(
                        this.anim, this.spriteSet.stall
                    );
                    
                } else {

                    this.frameCount = 0;
                    
                    if (
                        this.spriteSet !== allSprites.bobbing &&
                        this.spriteSet !== allSprites.duckoff
                    ) {
                        
                        this.spriteSet[0].dispatchEnd();
                        
                    } else {
                    
                        allSprites.bobbing.stall = 100 + 80 * rand();
                        
                    }
                    
                    if (this.nextSet !== this.spriteSet) {

                        this.spriteSet = this.nextSet;
                        this.nextSet = this.spriteSet;

                    }
                    
                    this.isLooping = setTimeout(
                        this.play, this.spriteSet.stall
                    );
                    
                }

            }
            
        };
    
        this.play = () => {
            
            if (!this.looping) {
                
                this.frameEnd = Object.values(
                    this.spriteSet[0].steps
                )[0].length;
                
                this.isLooping = setTimeout(this.anim, 0);
                
            }
            
        };
    
        this.pause = () => {
            this.isLooping = clearTimeout(this.isLooping);
        };
        
        const swap = s => {
                            
                this.frameCount = 0;
                this.spriteSet = s;
                this.isLooping = setTimeout(this.play, 50);
                boxShadow.addEventListener('spriteend', () => canKey = true);
            
        };
        
        this.switchTo = s => {
            
            this.isLooping = clearTimeout(this.isLooping);
            
            boxShadow.removeEventListener('spriteend', ()=>canKey=true);
            
            this.swapTimeout = clearTimeout(this.swapTimeout);
            
            swap(s);
            
        }
    
    };
    
    //aniMaker.play();
        
    //}
     
    // combo list {
    
    const comboList = {
        
        SS : () => {
            if (shockGroup.children[0]) {
                shockGroup.removeChild(shockGroup.children[0]);
            }
            aniMaker.switchTo(allSprites.slicing);
        },
      
        FF : () => {
            aniMaker.switchTo(allSprites.twister);
        },
        
        EE  : () => {
            
            let T = boxOver.style.transform.match(/-?\d+/g)
        
            boxShadow.addEventListener('spriteend', e => {
                new Echo(T[0], T[1], 0);
                new Echo(T[0], T[1], 180);
                if (rand() > 0.8 ) {
                    new Echo(T[0], T[1], 200, 2000, 5);
                }
            }, { once: true });
        
            boxOver.style.setProperty('--xtra', 6);
            boxGroup.style.setProperty('--xtra', 6);
            aniMaker.switchTo(allSprites.hopaway);
            
        },
        
        EF : () => {
            
            mirror = mirror === 1 ? -1 : 1;
            boxMirror.style.transform = 'scale('+ mirror +', 1)';
        }
        
    };
    
    //}
    
    // key combo stuff {
    
    let keyCombo = '';
    let keyWaiting = '';
    
    const keyComboLiz = e => keyCombo += e.key;
    
    const firstKeyLiz = e => {
        window.removeEventListener('keypress', firstKeyLiz);
        keyCombo += e.key;
        window.addEventListener('keypress', keyComboLiz);
        keyWaiting = setTimeout(endKeyLiz, prefs.keyComboLimit);
    };
    
    const endKeyLiz = () => {
        
        window.removeEventListener('keypress', keyComboLiz);
        
        if (comboList[keyCombo]) {
            
            canKey = false;
            comboList[keyCombo]();
            setTimeout(() => {
                window.addEventListener('keypress', firstKeyLiz);
            }, 1000)
            
        } else {
            window.addEventListener('keypress', firstKeyLiz);
        }
        
        keyCombo = '';
        
    }
    
    window.addEventListener('keypress', firstKeyLiz);
    
    //}
    
    // touch combo stuff {
        
    let touchCombo = '';
    let touchShift = false;
    let touchWaiting = '';
    
    const touchComboLiz = e => {
        
        let key = e.target.id.replace(/key/g, '');
        touchCombo += touchShift ? key : key.toLowerCase();
        
    };
    
    const firstTouchLiz = e => {
        
        let key = e.target.id.replace(/key/g, '');
        touchCombo = touchShift ? key : key.toLowerCase();
        
        [Skey,Fkey,Ekey].forEach(butt => {
            
            butt.removeEventListener('touchstart', firstTouchLiz);
            butt.addEventListener('touchstart', touchComboLiz);
            
        });
        
        touchWaiting = setTimeout(endTouchLiz, prefs.touchComboLimit);
        
    };
    
    const endTouchLiz = e => {
        
        [Skey, Fkey, Ekey].forEach(butt =>
            butt.removeEventListener('touchstart', touchComboLiz)
        );
    
        if (comboList[touchCombo]) {
    
            canKey = false;
            comboList[touchCombo]();
    
            boxShadow.addEventListener('spriteend', e => {
    
                [Skey, Fkey, Ekey].forEach(butt =>
                    butt.addEventListener(
                        'touchstart', firstTouchLiz
                    )
                );
    
            });
    
        }
        else {
    
            [Skey, Fkey, Ekey].forEach(butt =>
                butt.addEventListener(
                    'touchstart', firstTouchLiz
                )
            );
    
        }
    
        touchCombo = '';
    
    };
        
    [Skey,Fkey,Ekey].forEach(butt =>
        butt.addEventListener('touchstart', firstTouchLiz)
    );
    
    
    //}
    
    // lizzers {
    
    const reqFullscreen = e => holder.requestFullscreen();
    
    const touchEater = e => {
        e.stopPropagation();
        e.preventDefault();
    };
    
    const dukLizzer = e => {
        
        if (e.code === 'KeyD') {
            
            canKey = true;
            
            aniMaker.frameCount = 0;
            aniMaker.spriteSet = allSprites.bobbing;
            aniMaker.nextSet = allSprites.bobbing;
            
            window.removeEventListener('keyup', dukLizzer);
            window.addEventListener('keypress', firstKeyLiz);
            
        }
        
    };
    
    const keyLizzer = e => {
    
        e.stopPropagation();
        e.preventDefault();
        
        //if (e.repeat) return;
    
        if (e.code === 'Space') {
    
            if (aniMaker.isLooping) {
                aniMaker.pause();
                if (echoGroup.children) {
                    echoGroup.childNodes.forEach(c => {
                        c.childNodes.forEach(n => {
                            n.style.animationPlayState = 'paused';
                        });
                    });
                }
                if (shineGroup.children) {
                    shineGroup.childNodes.forEach(c => {
                        c.childNodes.forEach(n => {
                            n.style.animationPlayState = 'paused';
                        });
                    });
                }
            }
            else {
                aniMaker.play();
                if (echoGroup.children) {
                    echoGroup.childNodes.forEach(c => {
                        c.childNodes.forEach(n => {
                            n.style.animationPlayState = 'running';
                        });
                    });
                }
                if (shineGroup.children) {
                    shineGroup.childNodes.forEach(c => {
                        c.childNodes.forEach(n => {
                            n.style.animationPlayState = 'running';
                        });
                    });
                }
            }
    
        }
        
        if (!canKey) return;
        
        if (e.code === 'KeyS' || e.code === 'KeyF') {
        
            canKey = false;
            
            if (e.shiftKey) {
                
                aniMaker.switchTo(allSprites[
                    e.code === 'KeyS' ? 'kicking' : 'puncher'
                ]);
                
                return;
                
            }
        
            aniMaker.pause();
            aniMaker.frameCount = 3;
            
            let xDir = e.code === 'KeyS' ? -1 : 1;
            
            boxGroup.style.transform = `
                translate(${xDir * mirror}px, -3px)
            `;
            
            //boxBody.style.d = POS.body.stand;
            //boxShade.style.d = POS.shade.stand;
            
            boxShadow.style.transform = `
                translate(${(xDir * mirror) === 1 ? 4 : 2}px, 0px)
            `;
            
            setTimeout(() => {
        
                canKey = true;
                let T = boxOver.style.transform.match(/-?\d+/g)
                    .map(v => Number(v));
                    
                boxOver.style.transform = 'translate(' + (
                    (T[0] + xDir * 3) + 'px,' +
                    T[1] + 'px'
                ) + ')';
                    
                boxGroup.style.transform = 'translate(0px)';
                boxShadow.style.transform = 'translate(0px)';
                
                aniMaker.play();
        
            }, prefs.moveStall);
        
        }
        
        else if (e.code === 'KeyE') {
            
            canKey = false;
            
            if (e.shiftKey) {
                
                boxOver.style.setProperty('--xtra', 4.3);
                boxGroup.style.setProperty('--xtra', 4.3);
                aniMaker.switchTo(allSprites.hopkick);
                
            } else {
                
                if (rand() > 0.7) new Shine(
                    allSprites.hopping.stall * 5,
                    allSprites.hopping.stall * 2
                );
                boxOver.style.setProperty('--xtra', 4);
                boxGroup.style.setProperty('--xtra', 4);
                aniMaker.switchTo(allSprites.hopping);
                
            }
            
            
        }
        
        else if (e.code === 'KeyD') {
            
            if (e.shiftKey) { return; }
            
            canKey = false;
            aniMaker.pause();
            aniMaker.frameCount = 0;
            aniMaker.spriteSet = allSprites.duckoff;
            aniMaker.nextSet = allSprites.duckoff;
            aniMaker.play();
            
            window.removeEventListener('keypress', firstKeyLiz);
            window.addEventListener('keyup', dukLizzer);
        }
    
    };
    
    const buttLiz = key => {
        
        if (!canTouch) return;
        
        keyLizzer({
            code : key,
            shiftKey : touchShift,
            stopPropagation : () => {},
            preventDefault : () => {}
        });
        
    };
    
    //}
    
    // add lizzers {
    
    window.addEventListener('keypress', keyLizzer, {passive: false});
    
    Skey.addEventListener('touchstart', e => {
            buttLiz('KeyS');
    }, {passive: false});
    
    Fkey.addEventListener('touchstart', e => {
        buttLiz('KeyF');
    }, {passive: false});
    
    Ekey.addEventListener('touchstart', e => {
        buttLiz('KeyE');
    }, {passive: false});
    
    ShiftButt.addEventListener('touchstart', e => {
        touchShift = true;
        ShiftButt.style.borderColor = 'hsla(0,0%,0%,0.8)';
    }, {passive: false});
    
    ShiftButt.addEventListener('touchend', e => {
        touchShift = false;
        ShiftButt.style.borderColor = 'hsla(0,0%,0%,0.2)';
    }, {passive: false});
    
    window.addEventListener('click', reqFullscreen, {once: true});
    
    holder.addEventListener('fullscreenchange', e=> {
        
        if (document?.fullscreenElement) {

            window.addEventListener(
                'touchmove', touchEater, {passive: false}
            );
            
        } else {
            
            window.removeEventListener(
                'touchmove', touchEater, {passive: false}
            );
            
            window.addEventListener(
                'click', reqFullscreen, {once: true}
            );
            
        }
        
    });
    
    //}
    
    aniMaker.play();
    
}))() === undefined || (console.log('eXp!red'));

// }

</script>

</html>